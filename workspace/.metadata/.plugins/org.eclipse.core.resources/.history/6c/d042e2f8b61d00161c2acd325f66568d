import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.TooManyListenersException;

import gnu.io.*;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

/**
 * Read from a Serial port, notifying when data arrives.
 * Simulation of part of an event-logging service.
 * @version $Id: SerialReadByEvents.java,v 1.4 2004/04/11 23:50:40 ian Exp $
 * @author  Ian F. Darwin, http://www.darwinsys.com/
 */
public class SerialReadByEvents extends CommPortOpen 
  implements SerialPortEventListener {

  public static void main(String[] argv)
    throws IOException, NoSuchPortException, PortInUseException,
      UnsupportedCommOperationException {

    new SerialReadByEvents(null).converse();
  }

  /* Constructor */
  public SerialReadByEvents(JFrame f)
    throws IOException, NoSuchPortException, PortInUseException,
      UnsupportedCommOperationException {
    
    super(f);
  }

  /** 
   * Hold the conversation. 
   */
  protected void converse() throws IOException {

    if (!(thePort instanceof SerialPort)) {
      System.err.println("But I wanted a SERIAL port!");
      System.exit(1);
    }
    // Tell the Comm API that we want serial events.
    ((SerialPort)thePort).notifyOnDataAvailable(true);
    try {
      ((SerialPort)thePort).addEventListener(this);
    } catch (TooManyListenersException ev) {
      // "CantHappen" error
      System.err.println("Too many listeners(!) " + ev);
      System.exit(0);
    }
  
    
  }
  public void serialEvent(SerialPortEvent ev) {
    String line;
    try {
      line = is.readLine();
      if (line == null) {
        System.out.println("EOF on serial port.");
        System.exit(0);
      }
      os.println(line);
    } catch (IOException ex) {
      System.err.println("IO Error " + ex);
    }
  }
}


/**
 * Open a serial port using Java Communications.
 *
 * @author  Ian F. Darwin, http://www.darwinsys.com/
 */
class CommPortOpen {
  /** How long to wait for the open to finish up. */
  public static final int TIMEOUTSECONDS = 30;
  /** The baud rate to use. */
  public static final int BAUD = 19200;
  /** The parent JFrame, for the chooser. */
  protected JFrame parent;
  /** The input stream */
  protected BufferedReader is;
  /** The output stream */
  protected PrintStream os;
  /** The chosen Port Identifier */
  CommPortIdentifier thePortID;
  /** The chosen Port itself */
  CommPort thePort;

  public static void main(String[] argv)
    throws IOException, NoSuchPortException, PortInUseException,
      UnsupportedCommOperationException {

    new CommPortOpen(null).converse();

    System.exit(0);
  }

  /* Constructor */
  public CommPortOpen(JFrame f)
    throws IOException, NoSuchPortException, PortInUseException,
      UnsupportedCommOperationException {
    
    // Use the PortChooser from before. Pop up the JDialog.
    PortChooser chooser = new PortChooser(null);

    String portName = null;
    do {
      chooser.setVisible(true);
      
      // Dialog done. Get the port name.
      portName = chooser.getSelectedName();

      if (portName == null)
        System.out.println("No port selected. Try again.\n");
    } while (portName == null);

    // Get the CommPortIdentifier.
    thePortID = chooser.getSelectedIdentifier();

    // Now actually open the port.
    // This form of openPort takes an Application Name and a timeout.
    // 
    System.out.println("Trying to open " + thePortID.getName() + "...");

    switch (thePortID.getPortType()) {
    case CommPortIdentifier.PORT_SERIAL:
      thePort = thePortID.open("DarwinSys DataComm",
        TIMEOUTSECONDS * 1000);
      SerialPort myPort = (SerialPort) thePort;

      // set up the serial port
      myPort.setSerialPortParams(BAUD, SerialPort.DATABITS_8,
        SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);
      break;

    case CommPortIdentifier.PORT_PARALLEL:
      thePort = thePortID.open("DarwinSys Printing",
        TIMEOUTSECONDS * 1000);
      ParallelPort pPort = (ParallelPort)thePort;

      // Tell API to pick "best available mode" - can fail!
      // myPort.setMode(ParallelPort.LPT_MODE_ANY);

      // Print what the mode is
      int mode = pPort.getMode();
      switch (mode) {
        case ParallelPort.LPT_MODE_ECP:
          System.out.println("Mode is: ECP");
          break;
        case ParallelPort.LPT_MODE_EPP:
          System.out.println("Mode is: EPP");
          break;
        case ParallelPort.LPT_MODE_NIBBLE:
          System.out.println("Mode is: Nibble Mode.");
          break;
        case ParallelPort.LPT_MODE_PS2:
          System.out.println("Mode is: Byte mode.");
          break;
        case ParallelPort.LPT_MODE_SPP:
          System.out.println("Mode is: Compatibility mode.");
          break;
        // ParallelPort.LPT_MODE_ANY is a "set only" mode;
        // tells the API to pick "best mode"; will report the
        // actual mode it selected.
        default:
          throw new IllegalStateException("Parallel mode " + 
            mode + " invalid.");
      }
      break;
    default:  // Neither parallel nor serial??
      throw new IllegalStateException("Unknown port type " + thePortID);
    }

    // Get the input and output streams
    // Printers can be write-only
    try {
      is = new BufferedReader(new InputStreamReader(thePort.getInputStream()));
    } catch (IOException e) {
      System.err.println("Can't open input stream: write-only");
      is = null;
    }
    os = new PrintStream(thePort.getOutputStream(), true);
  }

  /** This method will be overridden by non-trivial subclasses
   * to hold a conversation. 
   */
  protected void converse() throws IOException {

    System.out.println("Ready to read and write port.");

    // Input/Output code not written -- must subclass.

    // Finally, clean up.
    if (is != null)
      is.close();
    os.close();
  }
}

